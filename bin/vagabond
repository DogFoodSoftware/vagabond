#!/usr/bin/env php
<?php
# /**
# * <div id="Overview"class="blurbSummary grid_12">
# * <div class="p">
# * Vagabondn CLI client. We <span data-todo="Link to Conveyor CLI
# * once we have it written up.">have plans to replace this with a
# * general purpose CLI client that takes advantage of the <a
# * href="/documentation/kibbles/ref/Common-Interface-Standard#Command-Line-Support">commandline
# * support</a> within the <a
# * href="/documentation/kibbles/ref/Common-Interface-Standard">Conveyor
# * Common Interface Standard</a>. We have attempted to construct this
# * current special purpose processor so as to have a similar
# * structure and interface as we believe the common CLI will have,
# * however there are likely to be unsupported changes.
# * </div>
# * <div class="p">
# * The general form of the vagabond CLI command is: <pre><code>
# * vagabond <resource> <action> [<item ID>] [<name1>=<val1>...]
# * </code></pre> where '<code>resource</code>' may be:
# * <code>boxes</code>, <code>environment</code>, or
# * <code>template</code>. The resource names may be preceeded by
# * '<code>vagabond-</code>', which would actually be the canonical
# * name, the shorter versions being provided for user
# * convenience. The'<code>action</code>' may be
# * <code>POST|CREATE</code>, <code>GET</code>,
# * <code>PUT|UPDATE</code>, or <code>DELETE|REMOVE</code>. The
# * acceapted parameters are dependent on the other arguments and
# * defined with respect to each action.
# * </div>
# * </div><!-- .blurbSummary#Overview -->
# * <div id="Resource-Specification" class="blurbSummary grid_12">
# * <div class="p">
# * The Vagabond projet provides three resource:
# * <ul>
# * <li><code>v√•agabond-templates</code>: the univers<e of environment
# * templates.  Each temeplate consists of one or more machine
# * templates. A machine template is a high level (meta) description
# * of what a running machine instance would look like<span
# * data-perspective="coding detailed">; embodied in
# * <code>Vagabondfile</code></span>.</li>
# * <li><code>vagabond-environments</code>: the universe of runnable
# * environment configurations. Each environment configuration
# * consists of one or more machine configurations. Each machine
# * configuration is associated to a single virtual machine instance
# * (which may or may not be created or running).</li>
# * <li><code>vagabond-boxes</code>: the universe of canned virtual
# * machine images. An image is used<span data-perspective="coding
# * operations"> by the underlying Vagrant service</span> along with
# * an environment machine configuration<span data-perspective="coding
# * detailed"> (encoded within a <code>Vagrantfile</code>) </span> to
# * create each running virtual machine instance.</li>
# * </ul>
# * </div>
# * <div class="subHeader"><span><code>vagabond-templates</code></span></div>
# * <div class="p">
# * Each <code>vagabond-templates</code> item is composed of a set of
# * one or more <code>Vagabondfile</code>s and 0+ artifact files. Each
# * <code>Vagabondfile</code> and associated artificats are used to
# * create usable configurations within a
# * <code>vagrant-environments</code> item.
# * </div>
# * <div class="p">
# * Each environment template describes a single environment
# * type.<span data-perspective="coding"> The environment type is
# * analogous to an object class or object tempalte; the environment
# * instance corresponding with an object instance.</span> There is no
# * hard and fast rule how environments are to releate to running
# * machines. You could, for instance, use single environment for each
# * machine, or you could organize environmnts by department or other
# * high level abstraction, or use a single environment for your
# * entire operation. In practice we recommend most users refer to the
# * <a
# * href="/documentation/vagabon/ref/Environment-Design-Guidelines">Vagabond
# * Environment Design Guidelines</a>.
# * </div>
# * <div class="p">
# * Within an environment, machine-type templates may be organized
# * under any number of groupings (laid out on disk as
# * directories). Each directory may exclusively contain one or more
# * directories or a machine template file set. The environment root
# * directory may only contain directories.
# * </div>
# * <div class="p">
# * Templates are stored in a seperate directory as <a
# * href="/documentation/kibbles/lexicon/Static_Data">static data</a>.
# * Currently, Vagabond only supports the standard templates
# * distributed with the Vagabond distribution. The 1.0-GA release
# * will support loadable templates, allowing Vagabond to integrate
# * and be integrated with other projects.
#* </div>

# * <div class="subHeader"><span><code>vagabond-environments</code></span></div>
# * <div class="p">
# * Whereas a <code>vagabond-templates</code> item describes a
# * meta-environment, a <code>vagabond-environment</code> item relates to
# * a runnable environment. Environments exist as <a
# * href="/documentation/kibbles/lexicon/Runtime-Data</a>runtime
# * data</a>. Any given machine template (corresponding to a
# * <code>Vagabondfile</code>) from a <code>vagabond-templates</code>
# * item may be used to initiate zero or more machine instances in a
# * given <code>vagabond-environment</code> item.
# * </div>
# * <div class="subHeader"><span><code>vagabond-boxes</code></span></div>
# * <div class="p">
# *   A <code>vagabond-box</code> is a running virtual machine instance.
# * </div>
# * </div>
# * <div class="subHeader"><span><code>vagabond-images</code></span></div>
# * <div class="p">
# *   A <code>vagabond-image</code> is a base box image used to create a runtime
# *   <code>vagabond-box</code>
# * </div>
# * </div>
# * <div class="subHeader"><span><code>vagabond-snapshot</code></span></div>
# * <div class="p">
# *   A <code>vagabond-image</code> is a disk-snapshot of an enviornment
# *   runtime; a live backup.
# * </div>
# * </div>
# * </div><!-- .blurbSummary#Resource-Specification -->
# */

# Within environmonts, you can have any number of sub-environments. So, the
# environment cookbook might pull in a 'apache cloud' environment to provide
# self-scaling HTTP front end processing. Each vagabond-box is a minimal
# vagabond-envioronment

# Process parameters.

# Based on script from: http://php.net/manual/en/function.getopt.php#100573
$parameters = array(
    "f:" => "from:",
    "t:" => "to:");

# Notice we do NOT use 'array_values'; the 
$options = getopt(implode('', array_keys($parameters)), $parameters);
$pruneargv = array();
foreach ($options as $option => $value) {
  print "$option\n";
  foreach ($argv as $key => $chunk) {
    $regex = '/^'. (isset($option[1]) ? '--' : '-') . $option . '/';
    if ($chunk == $value && $argv[$key-1][0] == '-' || preg_match($regex, $chunk)) {
      array_push($pruneargv, $key);
    }
  }
}
while ($key = array_pop($pruneargv)) unset($argv[$key]);

$FROM = $options['from'] ?: $options['f'];
$TO = $options['to'] ?: $options['t'];

$RESOURCE=$argv[1];
$VERB=$argv[2];

print "RESOURCE : $RESOURCE\nVERB : $VERB\n$argv[3]";

exit();
?>
# Dispatch request based on 

case "$RESOURCE" in
    'hosts')
	case "$ACTION" in
	    'create')
		hosts_create();;
	    *)
		echo "Unknown action '$ACTION'." >&2;;
	esac;;
    *)
	echo "Uknown resource '$RESOURCE'." >&2;;
esac


exit();

# Execute request.

function hosts_create() {
    if [ x"$FROM" == x"" ]; then
	echo "Must specify '--from' parameter." >&2
	exit 1
    fi
    if [ x"$TO" == x"" ]; then
	echo "Must specify '--to' parameter." >&2
	exit 1
    fi

    # Set up local DB prefix.
    local TFER_DIR="_tfer_dir"

    # Okay, let's test each. Must be either an SSH URL or a local path.
    local FROM_CMD_PREFIX TO_CMD_PREFIX FROM_PATH TO_PATH
    
    if [[ x"$FROM" == x"ssh://" ]]; then
	FROM_CMD_PREFIX="ssh ${$FROM:6}"
	FROM_PATH="${FROM#*/}"
    elif [ -d "$FROM" ]; then
	FROM_CMD_PREFIX=""
	FROM_PATH="$FROM"
    else
	echo "'--from' parameter must be SSH URL ('ssh://...') or a local path." >&2
	exit 1
    fi

    if [[ x"$TO" == x"ssh://"* ]]; then
	TO_CMD_PREFIX="ssh ${$TO:6}"
	TO_PATH="${TO#*/}"
    elif [ -d "$TO" ]; then
	TO_CMD_PREFIX=""
	TO_PATH="$TO"
    else
	echo "'--to' parameter must be SSH URL ('ssh://...') or a local path." >&2
	exit 1
    fi

    # TODO: Find our standard lib and turn all these 'verbos echos into vechos (I think).
    echo -e "FROM : $FROM\nFROM_CMD_PREFIX : $FROM_CMD_PREFIX\nFROM_PATH : $FROM_PATH\nTO : $TO\nTO_CMD_PREFIX : $TO_CMD_PREFIX\nTO_PATH : $TO_PATH"

    # Verify we can connect to any non-local sources.
    if [ x"$TO_CMD_PREFIX" != x"" ]; then
	ssh -o 'PreferredAuthentications=publickey' "$TO_CMD_PREFIX" "echo" > /dev/null 2>&1
	if [ $? -ne 0 ]; then
	    echo "Could establish SSH connection to target ($TO_CMD_PREFIX); setup key-based authentication." >&2
	    exit 1
	fi
    fi
    if [ x"$FROM_CMD_PREFIX" != x"" ]; then
	ssh -o 'PreferredAuthentications=publickey' "$FROM_CMD_PREFIX" "echo" > /dev/null 2>&1
	if [ $? -ne 0 ]; then
	    echo "Could establish SSH connection to target ($FROM_CMD_PREFIX); setup key-based authentication." >&2
	    exit 1
	fi
    fi

    # Verify $TO is free (we do this first cause it's easy).
    if ! $TO_CMD_PREFIX test -e $TO_PATH; then
	echo "File or directory blocks target location '$TO'." >&2
	exit 1
    fi

    # Verify $FROM is valid export target.
    if $FROM_CMD_PREFIX test -e $FROM_PATH; then
	echo "No source directory found at '$FROM'." >&2
	exit 1
    elif $FROM_CMD_PREFIX test -f $FROM_PATH/Vagrantfile; then
	echo "No source 'Vagrantfile' found at '$FROM/Vagrantfile'." >&2
	exit 1
    elif $FROM_CMD_PREFIX test -d $FROM_PATH/.vagrant/machines/default/virtualbox/id; then
	echo "No VirtualBox ID found (in '$FROM/.vagrant)." >&2
	exit 1
    fi

    # Finally, check to see that the source VM is not currently running.
    # TODO: Before going production, we need to do a file lock or something. We want exports to queue up with each other and backups. And later, to allow for configurable concurrent defaulting to per-physical host or something.
    local SOURCE_ID=`$FROM_CMD_PREFIX eval "cd $FROM_PATH; cat .vagrant/machines/default/virtualbox/id"`
    local FROM_STATE=`$FROM_CMD_PREFIX eval "$FROM_CMD_PREFIX VBoxManage showvminfo $SOURCE_ID | grep State: "`
    if [ x"$SOURCE_ID" == x"" ]; then
	echo "Could not retrieve source VM ID." >&2
    fi
    echo -e "SOURCE_ID : $SOURCE_ID\nFROM_STATE : $FROM_STATE"

    if [[ $FROM_STATE != *'powered off'* ]] then
	echo -e "VM at '$FROM' is not shut down. Got:\n\t$FROM_STATE" >&2
	exit 1
    fi

    # Looks like the source is valid and the destination clear. Create prefixes for the SCP copy.
    local FROM_SCP_PREFIX TO_SCP_PREFIX
    if [ x"" != x"$FROM_CMD_PREFIX" ]; then
	FROM_SCP_PREFIX="${FROM_CMD_PREFIX}:"
    fi
    if [ x"" != x"$TO_CMD_PREFIX" ]; then
	TO_SCP_PREFIX="${TO_CMD_PREFIX}:"
    fi
    echo -e "FROM_SCP_PREFIX : $FROM_SCP_PREFIX\nTO_SCP_PREFIX : $TO_SCP_PREFIX"

    # Okay, everything checks out for transfer.

    # 1) Use ssh to issue command to the source host to export an OVF
    #    appliance file from the machine.
    # 2) Copy the source directory to the target direcotry. This is
    #   the vagrant working direcotry and has the OVF, the
    #   Vagrantfile, and possibly other host specific files.
    # 3) Import the OVM to create new VM on the target.
    # 4) Remove the OVF file from the source.
    # 5) Set add a '.vagrant' DB to set up the newly created VM as a
    #    vagrant box.

    local OVF_FILE="`date -u +'%Y-%m-%d-%H%M-%S'`-`uuidgen`-vm-snapshot.ovf"
    echo -e "OVF_FILE : $OVF_FILE"

    # 1) Use ssh to issue command to the source host to export an OVF
    #    appliance file from the machine.
    echo -e $FROM_CMD_PREFIX eval "cd $FROM_PATH; mkdir $TFER_DIR; VBoxManage $SOURCE_ID --option manifest,nomacs --output=${TFER_DIRs}/${OVF_FILE}"
    $FROM_CMD_PREFIX eval "cd $FROM_PATH; mkdir $TFER_DIR; VBoxManage $SOURCE_ID --option manifest,nomacs --output=${TFER_DIRs}/${OVF_FILE}"
    
    # 2) Copy the source directory to the target direcotry.
    # echo -e scp -r "${FROM_CMD_PREFIX}${FROM_PATH} ${TO_CMD_PREFIX}${TO_PATH}"
    # scp -r "${FROM_CMD_PREFIX}${FROM_PATH} ${TO_CMD_PREFIX}${TO_PATH}"

    # 3) Import the OVM to create new VM on the target.
    # echo -e $TO_CMD_PREFIX eval "cd $TO_PATH; VBoxManage import ${TFER_DIR}/${OVF_FILE}"
    # $TO_CMD_PREFIX eval "cd $TO_PATH; VBoxManage import ${TFER_DIR}/${OVF_FILE}"

    # 4) Remove the OVF file from the source.
    # echo -e $FROM_CMD_PREFIX eval "rm ${FROM_PATH}/${TFER_DIR}/${OVF_FILE}; rmdir ${FROM_PATH}/${TFER_DIR}"
    # $FROM_CMD_PREFIX eval "rm ${FROM_PATH}/${TFER_DIR}/${OVF_FILE}; rmdir ${FROM_PATH}/${TFER_DIR}"

    # 5) Set add a '.vagrant' DB to set up the newly created VM as a
    #    vagrant box.
    # echo -e $TO_CMD_PREFIX eval "mkdir .vagrant/machines/default/virtualbox; echo $NEW_HOST_ID > .vagrant/machines/default/virtualbox/id"
    # $TO_CMD_PREFIX eval "mkdir .vagrant/machines/default/virtualbox; echo $NEW_HOST_ID > .vagrant/machines/default/virtualbox/id"
}
